name: AI变更日志生成
on:
  workflow_dispatch:
    inputs:
      version:
        description: '版本号(如v1.0.0）'
        required: true
        type: string
      release-id:
        description: 'Release ID（自动发布时填写）'
        required: false
        type: string
      tag:
        description: '要优化变更日志的标签（手动优化时填写）'
        required: false
        type: string
  workflow_call:
    inputs:
      version:
        description: '版本号'
        required: true
        type: string
      release-id:
        description: 'Release ID'
        required: true
        type: string
    outputs:
      ai_optimized:
        description: "是否完成AI优化"
        value: ${{ jobs.ai-changelog-generation.outputs.ai_optimized }}

jobs:
  ai-changelog-generation:
    name: AI变更日志生成
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      ai_optimized: ${{ steps.update-release-changelog.outputs.ai_optimized }}

    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 验证输入参数
      id: validate-params
      run: |
        if [ "${{ github.event_name }}" == "workflow_call" ]; then
          echo "RUN_MODE=workflow_call" >> $GITHUB_ENV
          echo "VERSION=${{ inputs.version }}" >> $GITHUB_ENV
          echo "RELEASE_ID=${{ inputs.release-id }}" >> $GITHUB_ENV
          echo "🔗 工作流调用模式: 版本 ${{ inputs.version }}, Release ID ${{ inputs.release-id }}"
        elif [ -n "${{ inputs.release-id }}" ]; then
          echo "RUN_MODE=auto_release" >> $GITHUB_ENV
          echo "VERSION=${{ inputs.version }}" >> $GITHUB_ENV
          echo "RELEASE_ID=${{ inputs.release-id }}" >> $GITHUB_ENV
          echo "🤖 自动发布模式: 版本 ${{ inputs.version }}, Release ID ${{ inputs.release-id }}"
        elif [ -n "${{ inputs.tag }}" ]; then
          echo "RUN_MODE=manual_optimize" >> $GITHUB_ENV
          echo "VERSION=${{ inputs.tag }}" >> $GITHUB_ENV
          echo "📝 手动优化模式: 标签 ${{ inputs.tag }}"
        else
          echo "❌ 必须提供发布ID或标签参数之一"
          exit 1
        fi    

    - name: 获取Release信息
      id: get-release-info
      run: |
        if [ "${{ env.RUN_MODE }}" == "auto_release" ]; then
          # 通过Release ID获取信息
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.PAT }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/${{ env.RELEASE_ID }}")
        else
          # 通过标签获取信息
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.PAT }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ env.VERSION }}")
        fi
        
        # 验证是否成功获取Release信息
        if [[ $(echo "$RELEASE_INFO" | jq -r 'has("id")') != "true" ]]; then
          echo "❌ 无法获取Release信息: $(echo "$RELEASE_INFO" | jq -r '.message // "未知错误"')"
          exit 1
        fi
        
        RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
        ORIGINAL_CHANGELOG=$(echo "$RELEASE_INFO" | jq -r '.body')
        
        echo "RELEASE_ID=$RELEASE_ID" >> $GITHUB_ENV
        echo "ORIGINAL_CHANGELOG<<EOF" >> $GITHUB_ENV
        echo "$ORIGINAL_CHANGELOG" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        
        echo "✅ 获取到Release信息，ID: $RELEASE_ID"
        echo "📋 原始变更日志长度: $(echo "$ORIGINAL_CHANGELOG" | wc -c) 字符"    

    - name: 检查是否已优(
      id: check-optimization-status
      run: |
        echo "🔍 检查变更日志优化状态..."
        
        # 更严格的AI优化检查
        if [[ "$ORIGINAL_CHANGELOG" == *"AI生成的变更日志摘要"* ]]; then
          echo "⚠️ 此Release已包含AI生成的变更日志"
          
          if [ "${{ env.RUN_MODE }}" == "manual_optimize" ]; then
            echo "📝 手动模式，强制重新生成AI变更日志"
            echo "NEED_OPTIMIZE=true" >> $GITHUB_ENV
            echo "FORCE_REGENERATE=true" >> $GITHUB_ENV
          else
            echo "🤖 自动模式，跳过重复优化"
            echo "NEED_OPTIMIZE=false" >> $GITHUB_ENV
          fi
        else
          echo "✅ 变更日志未经AI优化，可以进行优化"
          echo "NEED_OPTIMIZE=true" >> $GITHUB_ENV
        fi

    - name: 获取详细提交信息
      id: get-detailed-commits
      if: env.NEED_OPTIMIZE == 'true'
      run: |
        echo "📊 获取详细的提交信息...",////
        
        if [ "${{ env.RUN_MODE }}" == "manual_optimize" ] && [ "${{ env.FORCE_REGENERATE }}" == "true" ]; then
          echo "🔄 手动优化模式，从折叠区域提取原始提交记录..."
          
          # 从变更日志中提取原始提交记录
          ORIGINAL_COMMITS=$(echo "$ORIGINAL_CHANGELOG" | sed -n '/<details>/,/<\/details>/p' | sed '1d;$d' | sed '/^<summary>/d' | sed '/^<\/summary>/d' | sed '/^$/d')
          
          if [ -n "$ORIGINAL_COMMITS" ]; then
            echo "✅ 从折叠区域提取到原始提交记录"
            echo "COMMITS_RAW<<EOF" >> $GITHUB_ENV
            echo "$ORIGINAL_COMMITS" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            
            COMMIT_COUNT=$(echo "$ORIGINAL_COMMITS" | wc -l)
            echo "📋 使用折叠区域中的 $COMMIT_COUNT 行提交记录"
          else
            echo "⚠️ 无法从折叠区域提取原始记录，使用Git历史"
            # 获取上一个版本的标签
            LAST_TAG=$(git tag --sort=-version:refname | grep -v "^${{ env.VERSION }}$" | head -1)
            
            if [ -z "$LAST_TAG" ]; then
              echo "📋 首次发布，获取所有提交记录"
              COMMIT_RANGE=""
            else
              echo "📋 获取自 $LAST_TAG 以来的提交记录"
              COMMIT_RANGE="$LAST_TAG..${{ env.VERSION }}"
            fi
            ,
            # 获取详细的提交信息
            if [ -z "$COMMIT_RANGE" ]; then
              COMMITS=$(git log --pretty=format:'%h|%s|%b' --no-merges)
            else
              COMMITS=$(git log $COMMIT_RANGE --pretty=format:'%h|%s|%b' --no-merges)
            fi
            
            echo "COMMITS_RAW<<EOF" >> $GITHUB_ENV
            echo "$COMMITS" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            
            COMMIT_COUNT=$(echo "$COMMITS" | wc -l)
            echo "✅ 获取到 $COMMIT_COUNT 个提交记录"
          fi
        else
          echo "🆕 首次生成，从Git历史获取提交记录..."
          
          # 获取上一个版本的标签
          LAST_TAG=$(git tag --sort=-version:refname | grep -v "^${{ env.VERSION }}$" | head -1)
          
          if [ -z "$LAST_TAG" ]; then
            echo "📋 首次发布，获取所有提交记录"
            COMMIT_RANGE=""
          else
            echo "📋 获取自 $LAST_TAG 以来的提交记录"
            COMMIT_RANGE="$LAST_TAG..${{ env.VERSION }}"
          fi
          
          # 获取详细的提交信息
          if [ -z "$COMMIT_RANGE" ]; then
            COMMITS=$(git log --pretty=format:'%h|%s|%b' --no-merges)
          else
            COMMITS=$(git log $COMMIT_RANGE --pretty=format:'%h|%s|%b' --no-merges)
          fi
          
          # 保存提交信息到环境变量
          echo "COMMITS_RAW<<EOF" >> $GITHUB_ENV
          echo "$COMMITS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          COMMIT_COUNT=$(echo "$COMMITS" | wc -l)
          echo "✅ 获取到 $COMMIT_COUNT 个提交记录"
        fi

    - name: 分析并生成AI变更日志
      id: generate-ai-changelog
      if: env.NEED_OPTIMIZE == 'true'
      run: |
        echo "🤖 开始生成精美的AI变更日志..."
        
        # 初始化各类别的提交数组
        declare -a FEATURE_COMMITS=()
        declare -a FIX_COMMITS=()
        declare -a STYLE_COMMITS=()
        declare -a REFACTOR_COMMITS=()
        declare -a PERF_COMMITS=()
        declare -a DOCS_COMMITS=()
        declare -a BUILD_COMMITS=()
        declare -a OTHER_COMMITS=()
        
        # 处理从折叠区域提取的原始记录或Git历史记录
        if [ "${{ env.RUN_MODE }}" == "manual_optimize" ] && [ "${{ env.FORCE_REGENERATE }}" == "true" ]; then
          echo "🔄 处理从折叠区域提取的原始提交记录..."
          
          # 解析原始记录（可能是多种格式）
          while IFS= read -r line; do
            if [[ -n "$line" && "$line" != *"<details>"* && "$line" != *"</details>"* && "$line" != *"<summary>"* && "$line" != *"</summary>"* ]]; then
              # 尝试从不同格式中提取信息
              if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*([a-f0-9]{7,})[[:space:]]*(.+)$ ]]; then
                # 格式: - hash message
                hash="${BASH_REMATCH[1]}"
                message="${BASH_REMATCH[2]}"
              elif [[ "$line" =~ ^[[:space:]]*([a-f0-9]{7,})[[:space:]]+(.+)$ ]]; then
                # 格式: hash message
                hash="${BASH_REMATCH[1]}"
                message="${BASH_REMATCH[2]}"
              elif [[ "$line" =~ ^[[:space:]]*\*[[:space:]]*([a-f0-9]{7,})[[:space:]]*(.+)$ ]]; then
                # 格式: * hash message
                hash="${BASH_REMATCH[1]}"
                message="${BASH_REMATCH[2]}"
              else
                # 跳过无法解析的行
                continue
              fi
              
              # 清理消息内容
              clean_message=$(echo "$message" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
              
              # 分类提交
              if [[ "$clean_message" =~ ^(feat|feature|新增|添加) ]]; then
                FEATURE_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(fix|bug|修复|解决) ]]; then
                FIX_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(style|ui|样式|界面) ]]; then
                STYLE_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(refactor|重构) ]]; then
                REFACTOR_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(perf|performance|优化|性能) ]]; then
                PERF_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(docs|doc|文档) ]]; then
                DOCS_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(build|版本|构建) ]]; then
                BUILD_COMMITS+=("$hash|$clean_message")
              else
                OTHER_COMMITS+=("$hash|$clean_message")
              fi
            fi
          done <<< "$COMMITS_RAW"
        else
          echo "🆕 处理Git历史提交记录..."
          
          # 解析Git历史记录
          while IFS='|' read -r hash message body; do
            if [[ -n "$hash" ]]; then
              # 清理消息内容
              clean_message=$(echo "$message" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
              
              # 分类提交
              if [[ "$clean_message" =~ ^(feat|feature|新增|添加) ]]; then
                FEATURE_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(fix|bug|修复|解决) ]]; then
                FIX_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(style|ui|样式|界面) ]]; then
                STYLE_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(refactor|重构) ]]; then
                REFACTOR_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(perf|performance|优化|性能) ]]; then
                PERF_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(docs|doc|文档) ]]; then
                DOCS_COMMITS+=("$hash|$clean_message")
              elif [[ "$clean_message" =~ ^(build|版本|构建) ]]; then
                BUILD_COMMITS+=("$hash|$clean_message")
              else
                OTHER_COMMITS+=("$hash|$clean_message")
              fi
            fi
          done <<< "$COMMITS_RAW"
        fi
        
        # 生成统计信息
        echo "📊 初步分类统计:"
        echo "  - 功能新增: ${#FEATURE_COMMITS[@]}"
        echo "  - 问题修复: ${#FIX_COMMITS[@]}"
        echo "  - 样式优化: ${#STYLE_COMMITS[@]}"
        echo "  - 代码重构: ${#REFACTOR_COMMITS[@]}"
        echo "  - 性能优化: ${#PERF_COMMITS[@]}"
        echo "  - 文档更新: ${#DOCS_COMMITS[@]}"
        echo "  - 构建相关: ${#BUILD_COMMITS[@]}"
        echo "  - 其他改进: ${#OTHER_COMMITS[@]}"
        # 准备所有提交信息给DeepSeek API分析
        ALL_COMMITS_FOR_AI=""
        for commit in "${FEATURE_COMMITS[@]}" "${FIX_COMMITS[@]}" "${STYLE_COMMITS[@]}" "${REFACTOR_COMMITS[@]}" "${PERF_COMMITS[@]}" "${DOCS_COMMITS[@]}" "${BUILD_COMMITS[@]}" "${OTHER_COMMITS[@]}"; do
          if [[ -n "$commit" ]]; then
            ALL_COMMITS_FOR_AI="$ALL_COMMITS_FOR_AI$commit\n"
          fi
        done

        echo "🧠 调用DeepSeek API进行智能分析和优化..."
        
        # 创建DeepSeek API请求
        cat > deepseek_request.json << EOF
        {
          "model": "deepseek-chat",
          "messages": [
            {
              "role": "system",
              "content": "你是一个专业的软件开发变更日志生成专家。请分析以下Git提交记录，对每个提交进行正确分类，并生成专业的变更日志。\n\n分类规则：\n- FEATURE: 新功能、新特性\n- FIX: Bug修复、问题解决\n- STYLE: UI/UX改进、样式调整\n- REFACTOR: 代码重构、结构优化\n- PERF: 性能优化\n- DOCS: 文档更新\n- BUILD: 构建、版本、CI/CD相关\n- OTHER: 其他类型\n\n要求：\n1. 保留原始的Git哈希值\n2. 如果初步分类不正确，请纠正\n3. 生成简洁专业的描述\n4. 按重要性排序\n5. 使用中文输出"
            },
            {
              "role": "user",
              "content": "请分析以下提交记录并生成优化的变更日志：\n\n$(echo -e "$ALL_COMMITS_FOR_AI")\n\n请按照JSON格式返回分析结果：\n{\n  \"categories\": {\n    \"FEATURE\": [{\"hash\": \"commit_hash\", \"message\": \"优化后的描述\", \"importance\": 1-5}],\n    \"FIX\": [...],\n    \"STYLE\": [...],\n    \"REFACTOR\": [...],\n    \"PERF\": [...],\n    \"DOCS\": [...],\n    \"BUILD\": [...],\n    \"OTHER\": [...]\n  },\n  \"summary\": \"版本整体改进摘要\",\n  \"highlights\": [\"主要亮点1\", \"主要亮点2\"]\n}"
            }
          ],
          "temperature": 0.3,
          "max_tokens": 4000
        }
        EOF

        # 调用DeepSeek API
        DEEPSEEK_RESPONSE=$(curl -s -X POST \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.DEEPSEEK_API_KEY }}" \
          "https://api.deepseek.com/v1/chat/completions" \
          -d @deepseek_request.json)

        # 检查API调用是否成功
        if [[ $(echo "$DEEPSEEK_RESPONSE" | jq -r 'has("choices")') == "true" ]]; then
          echo "✅ DeepSeek API调用成功"
          
          # 提取AI分析结果
          AI_CONTENT=$(echo "$DEEPSEEK_RESPONSE" | jq -r '.choices[0].message.content')
          
          # 尝试解析JSON结果
          if echo "$AI_CONTENT" | jq . > /dev/null 2>&1; then
            echo "📊 AI智能分析完成，开始生成优化变更日志..."
            
            # 保存AI分析结果
            echo "$AI_CONTENT" > ai_analysis.json
            
            # 提取摘要和亮点
            AI_SUMMARY=$(echo "$AI_CONTENT" | jq -r '.summary // "AI智能分析的版本更新"')
            AI_HIGHLIGHTS=$(echo "$AI_CONTENT" | jq -r '.highlights[]?' 2>/dev/null || echo "")
            
            # 开始生成优化后的变更日志
            AI_CHANGELOG="# 版本 ${{ env.VERSION }} 更新摘要 [AI生成的变更日志摘要]

            ## 📋 更新概览
            $AI_SUMMARY"
            
            # 添加主要亮点
            if [[ -n "$AI_HIGHLIGHTS" ]]; then
              AI_CHANGELOG="$AI_CHANGELOG

            ### ✨ 主要亮点"
              while IFS= read -r highlight; do
                if [[ -n "$highlight" ]]; then
                  AI_CHANGELOG="$AI_CHANGELOG
            - $highlight"
                fi
              done <<< "$AI_HIGHLIGHTS"
            fi
            
            AI_CHANGELOG="$AI_CHANGELOG

            ---"
            
            # 按优先级生成各个分类
            declare -a CATEGORIES=("FEATURE" "FIX" "PERF" "STYLE" "REFACTOR" "DOCS" "BUILD" "OTHER")
            declare -A CATEGORY_TITLES=(
              ["FEATURE"]="🚀 功能新增"
              ["FIX"]="🐛 问题修复"
              ["PERF"]="⚡ 性能优化"
              ["STYLE"]="💄 样式优化"
              ["REFACTOR"]="♻️ 代码重构"
              ["DOCS"]="📝 文档更新"
              ["BUILD"]="🏗️ 构建相关"
              ["OTHER"]="🔧 其他改进"
            )
            
            for category in "${CATEGORIES[@]}"; do
              # 检查该分类是否有提交
              CATEGORY_COMMITS=$(echo "$AI_CONTENT" | jq -r ".categories.$category[]?" 2>/dev/null)
              
              if [[ -n "$CATEGORY_COMMITS" ]]; then
                AI_CHANGELOG="$AI_CHANGELOG

            #### ${CATEGORY_TITLES[$category]}"
                
                # 按重要性排序并添加提交
                echo "$AI_CONTENT" | jq -r ".categories.$category | sort_by(-.importance) | .[] | \"\\(.hash)|\\(.message)|\\(.importance)\"" | while IFS='|' read -r hash message importance; do
                  if [[ -n "$hash" && -n "$message" ]]; then
                    # 根据重要性添加不同的图标
                    case $importance in
                      5) icon="🔥" ;;
                      4) icon="⭐" ;;
                      3) icon="✨" ;;
                      2) icon="📌" ;;
                      1) icon="📍" ;;
                      *) icon="•" ;;
                    esac
                    
                    AI_CHANGELOG="$AI_CHANGELOG
            - $icon **$message**  
              \`$hash\`"
                  fi
                done
              fi
            done
            
            echo "✅ AI优化变更日志生成完成"
            
          else
            echo "⚠️ DeepSeek API返回格式异常，使用基础分析结果"
            # 使用原有的基础分析逻辑作为后备
            AI_SUMMARY="基于智能分析的版本更新"
            
            # 生成基础变更日志
            AI_CHANGELOG="# 版本 ${{ env.VERSION }} 更新摘要 [AI生成的变更日志摘要]

            ## 📋 更新概览
            $AI_SUMMARY

            ---"
            
            # 功能新增部分
            if [ ${#FEATURE_COMMITS[@]} -gt 0 ]; then
              AI_CHANGELOG="$AI_CHANGELOG

            #### 🚀 功能新增"
              
              for commit in "${FEATURE_COMMITS[@]}"; do
                IFS='|' read -r hash message <<< "$commit"
                title=$(echo "$message" | sed 's/^feat[[:space:]]*:[[:space:]]*//' | sed 's/^feature[[:space:]]*:[[:space:]]*//' | sed 's/新增[[:space:]]*//' | sed 's/添加[[:space:]]*//')
                AI_CHANGELOG="$AI_CHANGELOG
            - **${title}**  
              \`$hash\`"
              done
            fi
            
            # 问题修复部分
            if [ ${#FIX_COMMITS[@]} -gt 0 ]; then
              AI_CHANGELOG="$AI_CHANGELOG

            #### 🐛 问题修复"
              
              for commit in "${FIX_COMMITS[@]}"; do
                IFS='|' read -r hash message <<< "$commit"
                title=$(echo "$message" | sed 's/^fix[[:space:]]*:[[:space:]]*//' | sed 's/^bug[[:space:]]*:[[:space:]]*//' | sed 's/修复[[:space:]]*//' | sed 's/解决[[:space:]]*//')
                AI_CHANGELOG="$AI_CHANGELOG
            - **${title}**  
              \`$hash\`"
              done
            fi
            
            # 其他分类的处理...
            if [ ${#PERF_COMMITS[@]} -gt 0 ]; then
              AI_CHANGELOG="$AI_CHANGELOG

            #### ⚡ 性能优化"
              for commit in "${PERF_COMMITS[@]}"; do
                IFS='|' read -r hash message <<< "$commit"
                AI_CHANGELOG="$AI_CHANGELOG
            - **$(echo "$message" | sed 's/^[^:]*:[[:space:]]*//')**  
              \`$hash\`"
              done
            fi
          fi
          
        else
          echo "❌ DeepSeek API调用失败，使用基础分析"
          echo "错误信息: $(echo "$DEEPSEEK_RESPONSE" | jq -r '.error.message // "未知错误"')"
          
          # 使用原有逻辑作为后备
          AI_CHANGELOG="# 版本 ${{ env.VERSION }} 更新摘要 [AI生成的变更日志摘要]

          ---"
          
          # 原有的基础分析逻辑...
          if [ ${#FEATURE_COMMITS[@]} -gt 0 ]; then
            AI_CHANGELOG="$AI_CHANGELOG

          #### 🚀 功能新增"
            
            for commit in "${FEATURE_COMMITS[@]}"; do
              IFS='|' read -r hash message <<< "$commit"
              title=$(echo "$message" | sed 's/^feat[[:space:]]*:[[:space:]]*//' | sed 's/^feature[[:space:]]*:[[:space:]]*//' | sed 's/新增[[:space:]]*//' | sed 's/添加[[:space:]]*//')
              AI_CHANGELOG="$AI_CHANGELOG
          - **${title}**  
            \`$hash\`"
            done
          fi
          
          if [ ${#FIX_COMMITS[@]} -gt 0 ]; then
            AI_CHANGELOG="$AI_CHANGELOG

          #### 🐛 问题修复"
            
            for commit in "${FIX_COMMITS[@]}"; do
              IFS='|' read -r hash message <<< "$commit"
              title=$(echo "$message" | sed 's/^fix[[:space:]]*:[[:space:]]*//' | sed 's/^bug[[:space:]]*:[[:space:]]*//' | sed 's/修复[[:space:]]*//' | sed 's/解决[[:space:]]*//')
              AI_CHANGELOG="$AI_CHANGELOG
          - **${title}**  
            \`$hash\`"
            done
          fi
        fi
        
        # 保存原始变更记录到折叠区域
        if [ "${{ env.RUN_MODE }}" == "manual_optimize" ] && [ "${{ env.FORCE_REGENERATE }}" == "true" ]; then
          ORIGINAL_FOR_COLLAPSE="$ORIGINAL_CHANGELOG"
        else
          ORIGINAL_FOR_COLLAPSE="$ORIGINAL_CHANGELOG"
        fi
        
        AI_CHANGELOG="$AI_CHANGELOG

        <details>
        <summary>查看原始提交记录</summary>

        $ORIGINAL_FOR_COLLAPSE

        </details>"
        
        # 保存生成的变更日志
        echo "AI_CHANGELOG<<EOF" >> $GITHUB_ENV
        echo "$AI_CHANGELOG" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        
        echo "✅ AI变更日志生成完成"
        echo "📝 变更日志长度: $(echo "$AI_CHANGELOG" | wc -c) 字符"
        
        # 清理临时文件
        rm -f deepseek_request.json ai_analysis.json 2>/dev/null || true
    - name: 更新Release变更日志
      id: update-release-changelog
      if: env.NEED_OPTIMIZE == 'true'
      run: |
        echo "📝 更新Release变更日志..."
        
        # 使用GitHub API更新Release
        UPDATE_RESPONSE=$(curl -s -X PATCH \
          -H "Authorization: token ${{ secrets.PAT }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/releases/${{ env.RELEASE_ID }}" \
          -d "{\"body\": $(echo "$AI_CHANGELOG" | jq -R -s '.')}")
        
        # 检查更新结果
        if [[ $(echo "$UPDATE_RESPONSE" | jq -r 'has("id")') == "true" ]]; then
          echo "✅ Release变更日志更新成功"
          echo "🔗 Release URL: $(echo "$UPDATE_RESPONSE" | jq -r '.html_url')"
          echo "ai_optimized=true" >> $GITHUB_OUTPUT
          
          # 添加到作业摘要
          echo "## 🤖 AI变更日志生成完成" >> $GITHUB_STEP_SUMMARY
          echo "| 项目 | 值 |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| 版本 | \`${{ env.VERSION }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Release ID | \`${{ env.RELEASE_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Release URL | [查看发布]($(echo "$UPDATE_RESPONSE" | jq -r '.html_url')) |" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Release变更日志更新失败"
          echo "错误信息: $(echo "$UPDATE_RESPONSE" | jq -r '.message // "未知错误"')"
          echo "ai_optimized=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: 清理临时文件
      if: always()
      run: |
        echo "🧹 清理临时文件..."
        find . -name "*.tmp" -delete 2>/dev/null || true
        echo "✅ 清理完成"